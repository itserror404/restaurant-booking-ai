# Restaurant Booking Agent

AI conversational agent for restaurant reservations built with LangGraph and GPT-4o-mini.

## Demo
Link: 

## Overview

This agent conducts natural conversations to collect booking details, creates reservations via a mock booking API, and sends SMS confirmations. It uses a state machine architecture to handle complex multi-turn conversations with proper error handling and recovery.

**Key Features:**
- Natural language booking collection
- Smart date/time interpretation
- Confirmation flow with change handling
- Error recovery with retry logic
- LangFuse observability integration
- Both CLI and web UI interfaces

## Quick Start

### Prerequisites
- Python 3.9+
- OpenAI API key
- (Optional) LangFuse account for tracing

### Installation
```bash
# Clone the repository
git clone https://github.com/itserror404/restaurant-booking-agent.git
cd restaurant-booking-agent

# Install dependencies
pip install -r requirements.txt

# Set up environment variables

# Create a new .env file (do not copy .env.example)
touch .env

# Add your API key inside .env:
OPENAI_API_KEY= your_api_key_here

MODEL_NAME=gpt-4o-mini                   # Optional, defaults to gpt-4o-mini
LANGFUSE_PUBLIC_KEY=your_langfuse_key    # Optional
LANGFUSE_SECRET_KEY=your_langfuse_secret # Optional
LANGFUSE_HOST=https://cloud.langfuse.com # Optional

```

### Running the Agent

**Option 1: Command Line Interface**
```bash
python main.py
```

**Option 2: Web Interface (Streamlit)**
```bash
streamlit run streamlit_app.py
```

## Architecture

### Framework Choice: LangGraph

**Why LangGraph?**
- **Stateful conversations**: Maintains context across multiple turns
- **Explicit control flow**: Clear state machine transitions for predictable behavior
- **Error handling**: Built-in support for conditional routing and recovery
- **Production-ready**: Proper observability and debugging tools

The agent uses a state machine with these key phases:
1. **Collection** → Gather booking details one field at a time
2. **Confirmation** → Show summary and get user approval
3. **Booking** → Create reservation via API
4. **SMS** → Send confirmation message

### State Management
```python
class BookingState(TypedDict):
    messages: List[BaseMessage]      # Conversation history
    restaurant_name: Optional[str]   # Booking details
    date: Optional[str]
    time: Optional[str]
    party_size: Optional[int]
    customer_name: Optional[str]
    phone: Optional[str]
    booking_ref: Optional[str]       # Generated after booking
    # Control flags
    all_info_collected: bool
    awaiting_confirmation: bool
    user_confirmed: bool
    conversation_complete: bool
```

### Graph Flow
```
image generated by langraph 
```
<img width="693" height="654" alt="graph" src="https://github.com/user-attachments/assets/6eb9287c-b70e-4ac4-9203-ebd42278ef02" />



## Example Conversation
<img width="946" height="794" alt="Screenshot 2025-11-28 at 1 20 17 AM" src="https://github.com/user-attachments/assets/a63bbd74-01cf-41f0-938c-44d1b8aa1479" />
<img width="1252" height="767" alt="Screenshot 2025-11-28 at 1 21 14 AM" src="https://github.com/user-attachments/assets/3d689cf6-bde5-4b6c-bdc9-b95717ab5660" />



## Edge Cases Handled

### 1. Smart Time Interpretation
- **Ambiguous times**: "7" → assumes 19:00 (7pm) for dinner
- **Explicit times**: "7pm", "19:00" → used as-is
- **Unusual times**: "2am" → asks for clarification

### 2. Date Validation
- **Past dates**: "January 1st" → rejects and asks for future date
- **Relative dates**: "tomorrow", "next week Wednesday" → calculates correctly
- **Far future**: Dates 6+ months out → asks for confirmation

### 3. Confirmation Handling
- **Clear confirmation**: "yes", "looks good" → proceeds to booking
- **Unclear responses**: "maybe", "um" → asks for explicit yes/no
- **Change requests**: "change time to 8pm" → extracts new value and re-confirms

### 4. Error Recovery
- **Booking API failure**: Retries once, then offers callback
- **SMS failure**: Shows booking details for user to screenshot
- **Invalid input**: Asks for clarification naturally

### 5. Flexible Input
- **All at once**: "Mario's tomorrow 7pm 4 people John 555-1234" → extracts all
- **Sequential**: Asks for one field at a time when needed
- **Updates**: "actually make it 6 people" → updates and continues

## Tech Stack

- **LangGraph**: State machine orchestration
- **GPT-4o-mini**: Language model for extraction and reasoning
- **LangChain**: LLM framework and structured outputs
- **Pydantic**: Type-safe data validation
- **Streamlit**: Web UI
- **LangFuse**: Observability and tracing
- **Python 3.9+**: Runtime

## Project Structure
```
restaurant-booking-agent/
├── agent/
│   ├── graph.py       # LangGraph workflow and statemachine
│   ├── nodes.py       # Node functions (collect, confirm, etc.)
│   └── state.py       # State type definition
├── apis/
│   ├── booking.py     # Mock booking API
│   └── sms.py         # Mock SMS API
├── test/
│   ├── test_unit.py        # Unit tests (16 tests)
│   ├── test_integration.py # Integration tests
│   └── test_helpers.py     # Test utilities
├── main.py            # CLI interface
├── streamlit_app.py   # Web UI
├── requirements.txt   # Dependencies
├── .env               # Environment-> create it
└── README.md         # This file
```

## Assumptions & Limitations

### Assumptions
- **Date format**: User's local timezone
- **Restaurant names**: Free text, no validation against database
- **Phone numbers**: Accepts various formats, normalizes automatically
- **Time interpretation**: Defaults to PM (14:00-23:00) for ambiguous hours

### Current Limitations
- **No persistence**: State resets between sessions (in-memory only)
- **Mock APIs**: Booking and SMS are simulated, not real integrations
- **No availability checking**: Assumes all times/dates are available
- **Sequential changes**: Post-confirmation changes require re-confirmation

### Known Issues
- None currently identified in core functionality
- OpenAI calls fail sometimes, reloading or restarting the server solves it.

## Productionization Roadmap

### Immediate Improvements (Phase 1)
1. **Real APIs**
2. **Data Persistence**
3. **Authentication**
4. **Availability Management**
5. **Improved Reasoning**
6. **User Experience**
7. **Better Testing** 
8. **Production Infrastructure**


## Design Decisions

### Sequential Collection:
Asking for one field at a time reduces ambiguity. When agent asks "What time?" and user says "2", it's clear they mean 2pm, not 2 people.

### PM Default for Times:
Most restaurant bookings are for dinner (6pm-10pm). Users booking breakfast naturally specify "9am". This reduces conversation turns for the common case.

### Interactive Graph Design:
Using `END` nodes to exit between user turns enables natural back-and-forth conversation. Alternative approaches ( like a single graph run) work for batch processing but not interactive chat.

### Structured Output:
Pydantic models with `with_structured_output()` ensure reliable data extraction. Alternative methods like parsing LLM text was tested but was it was fragile and changes every LLM call.

## Edge Cases Handled

### 1. Smart Time Interpretation
- **Ambiguous times**: "7" → assumes 19:00 (7pm) for dinner
- **Explicit times**: "7pm", "19:00" → used as-is
- **Unusual times**: "2am" → asks for clarification

### 2. Date Validation
- **Past dates**: "January 1st" → rejects and asks for future date
- **Relative dates**: "tomorrow", "next week Wednesday" → calculates correctly
- **Far future**: Dates 6+ months out → asks for confirmation

### 3. Confirmation Handling
- **Clear confirmation**: "yes", "looks good" → proceeds to booking
- **Unclear responses**: "maybe", "um" → asks for explicit yes/no
- **Change requests**: "change time to 8pm" → extracts new value and re-confirms

### 4. Error Recovery
- **Booking API failure**: Retries once, then offers callback
- **SMS failure**: Shows booking details for user to screenshot
- **Invalid input**: Asks for clarification naturally

### 5. Flexible Input
- **All at once**: "Mario's tomorrow 7pm 4 people John 555-1234" → extracts all
- **Sequential**: Asks for one field at a time when needed
- **Updates**: "actually make it 6 people" → updates and continues

## Testing

**Run unit tests:**
```bash
pytest test/ -v
```
**Test results:**
- 16 unit tests covering routing logic, API integration, error handling
- All tests passing

### Failure Testing

The mock APIs include built-in failure modes for testing error handling:

#### Booking API Failures
- **Random failures**: 5% failure rate (`BOOKING_FAILURE_RATE = 0.05`)
- **Test restaurant**: Use "Test Failure Restaurant" to force failure
- **Programmatic**: Set `simulate_failure=True` in unit tests

#### SMS API Failures  
- **Random failures**: 3% failure rate (`SMS_FAILURE_RATE = 0.03`)
- **Test phone**: Use "555-SMS-FAIL" to force failure
- **Programmatic**: Set `simulate_failure=True` in unit tests

#### Testing Commands
```bash
# Run specific failure tests
pytest test/test_unit.py::test_booking_api_failure -v
pytest test/test_unit.py::test_sms_api_failure -v

# Manual testing with failure triggers
# In CLI: Book at "Test Failure Restaurant" 
# In CLI: Use phone "555-SMS-FAIL"
```

#### Manual Test Scenarios
- **Ideal path**: Sequential info collection (restaurant → date → time → party → name → phone)
- **All at once**: Complete booking in one message ("Mario's tomorrow 7pm 4 people John 555-1234")
- **Change handling**: User modifies details during confirmation ("actually make it 8pm")
- **Error recovery**: API failures handled gracefully with retry and fallback
- **Edge cases**: Past dates, ambiguous times, unclear confirmations

  
## LangFuse Observability

This project integrates with LangFuse for comprehensive LLM observability and tracing.

### Setup
Add these environment variables (create a project under langfuse and create api keys) to your `.env` file:
```bash
LANGFUSE_PUBLIC_KEY=your_public_key
LANGFUSE_SECRET_KEY=your_secret_key
LANGFUSE_HOST=https://cloud.langfuse.com  
```

### Features Tracked
- **LLM Calls**: Every GPT-4o-mini call with input/output
- **Structured Outputs**: Booking info extraction and confirmation responses
- **Session Tracking**: Complete conversation flows with unique session IDs
- **Error Monitoring**: Failed API calls and recovery attempts
- **Performance Metrics**: Response times and token usage

### Viewing Traces
1. Visit your LangFuse dashboard
2. Filter by session ID (printed in CLI output)
3. View the complete conversation flow with LLM calls
4. Debug extraction issues and conversation logic

<img width="1451" height="726" alt="Screenshot 2025-11-28 at 1 37 00 AM" src="https://github.com/user-attachments/assets/bd3a76c7-d27d-447f-854f-ea777043ece8" />

